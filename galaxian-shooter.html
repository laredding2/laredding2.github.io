<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxian Shooter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div>← → Arrow Keys: Move</div>
        <div>SPACE: Shoot</div>
        <div>R: Restart (when game over)</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Constants
        const WIDTH = 800;
        const HEIGHT = 600;
        const FPS = 60;

        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        // Colors
        const BLACK = '#000000';
        const WHITE = '#FFFFFF';
        const BLUE = '#0064FF';
        const RED = '#FF3232';
        const YELLOW = '#FFFF00';
        const GREEN = '#00FF00';
        const CYAN = '#00FFFF';
        const ORANGE = '#FFA500';

        // Input handling
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ') e.preventDefault();
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Utility functions
        function randomRange(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomChoice(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // ExplosionParticle class
        class ExplosionParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                const angle = randomRange(0, 2 * Math.PI);
                const speed = randomRange(2, 6);
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = Math.floor(randomRange(20, 40));
                this.maxLife = this.life;
                this.size = Math.floor(randomRange(2, 5));
                this.color = randomChoice([RED, ORANGE, YELLOW, WHITE]);
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2; // Gravity
                this.life -= 1;
            }

            draw(ctx) {
                if (this.life > 0) {
                    const alphaRatio = this.life / this.maxLife;
                    const size = Math.floor(this.size * alphaRatio);
                    if (size > 0) {
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, size, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
            }
        }

        // Player class
        class Player {
            constructor() {
                this.x = WIDTH / 2;
                this.y = HEIGHT - 60;
                this.width = 40;
                this.height = 30;
                this.speed = 5;
                this.bullets = [];
                this.invulnerable = false;
                this.invulnTimer = 0;
            }

            move() {
                if (keys['ArrowLeft'] && this.x > 0) {
                    this.x -= this.speed;
                }
                if (keys['ArrowRight'] && this.x < WIDTH - this.width) {
                    this.x += this.speed;
                }
            }

            shoot() {
                this.bullets.push(new Bullet(this.x + this.width / 2, this.y));
            }

            draw(ctx) {
                // Flashing effect if invulnerable
                if (this.invulnerable && Math.floor(this.invulnTimer % 10) < 5) {
                    return;
                }

                // Draw player ship (triangle)
                ctx.fillStyle = GREEN;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y);
                ctx.lineTo(this.x, this.y + this.height);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.closePath();
                ctx.fill();
            }

            updateInvulnerability() {
                if (this.invulnerable) {
                    this.invulnTimer += 1;
                    if (this.invulnTimer > 120) { // 2 seconds at 60 FPS
                        this.invulnerable = false;
                        this.invulnTimer = 0;
                    }
                }
            }

            updateBullets(enemies) {
                let scoreGained = 0;
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    bullet.move();
                    
                    if (bullet.y < 0) {
                        this.bullets.splice(i, 1);
                    } else {
                        // Check collision with enemies
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            const enemy = enemies[j];
                            if (enemy.checkCollision(bullet)) {
                                this.bullets.splice(i, 1);
                                enemies.splice(j, 1);
                                scoreGained += 100;
                                break;
                            }
                        }
                    }
                }
                return scoreGained;
            }
        }

        // Bullet class
        class Bullet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.speed = 8;
                this.width = 3;
                this.height = 10;
            }

            move() {
                this.y -= this.speed;
            }

            draw(ctx) {
                ctx.fillStyle = YELLOW;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        // Enemy class
        class Enemy {
            constructor(x, y, row, speedMultiplier = 1.0) {
                this.x = x;
                this.y = y;
                this.startX = x;
                this.startY = y;
                this.width = 30;
                this.height = 25;
                this.speed = 1 * speedMultiplier;
                this.diving = false;
                this.diveSpeed = 3 * speedMultiplier;
                this.row = row;
                this.color = row < 2 ? CYAN : row < 4 ? RED : BLUE;
                this.bullets = [];
                this.speedMultiplier = speedMultiplier;
            }

            moveFormation(direction, down = false) {
                if (!this.diving) {
                    this.x += direction * this.speed;
                    if (down) {
                        this.y += 10;
                    }
                }
            }

            startDive(playerX) {
                this.diving = true;
                this.targetX = playerX;
            }

            updateDive() {
                if (this.diving) {
                    // Move toward player and down
                    if (this.x < this.targetX) {
                        this.x += this.diveSpeed;
                    } else if (this.x > this.targetX) {
                        this.x -= this.diveSpeed;
                    }

                    this.y += this.diveSpeed;

                    // Return to formation if off screen
                    if (this.y > HEIGHT) {
                        this.diving = false;
                        this.x = this.startX;
                        this.y = this.startY;
                    }
                }
            }

            shoot() {
                this.bullets.push(new EnemyBullet(this.x + this.width / 2, this.y + this.height, this.speedMultiplier));
            }

            checkCollision(bullet) {
                return (bullet.x >= this.x && bullet.x <= this.x + this.width &&
                        bullet.y >= this.y && bullet.y <= this.y + this.height);
            }

            checkPlayerCollision(player) {
                return (this.x < player.x + player.width &&
                        this.x + this.width > player.x &&
                        this.y < player.y + player.height &&
                        this.y + this.height > player.y);
            }

            draw(ctx) {
                // Draw enemy ship (inverted triangle)
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y + this.height);
                ctx.lineTo(this.x, this.y);
                ctx.lineTo(this.x + this.width, this.y);
                ctx.closePath();
                ctx.fill();

                // Wings
                ctx.fillRect(this.x - 5, this.y + 10, 5, 8);
                ctx.fillRect(this.x + this.width, this.y + 10, 5, 8);
            }
        }

        // EnemyBullet class
        class EnemyBullet {
            constructor(x, y, speedMultiplier = 1.0) {
                this.x = x;
                this.y = y;
                this.speed = 5 * speedMultiplier;
                this.width = 3;
                this.height = 10;
            }

            move() {
                this.y += this.speed;
            }

            draw(ctx) {
                ctx.fillStyle = RED;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            checkCollision(player) {
                return (this.x >= player.x && this.x <= player.x + player.width &&
                        this.y >= player.y && this.y <= player.y + player.height);
            }
        }

        // Create enemy formation
        function createEnemyFormation(speedMultiplier = 1.0) {
            const enemies = [];
            const rows = 5;
            const cols = 10;
            const startX = 100;
            const startY = 80;
            const spacingX = 60;
            const spacingY = 50;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = startX + col * spacingX;
                    const y = startY + row * spacingY;
                    enemies.push(new Enemy(x, y, row, speedMultiplier));
                }
            }

            return enemies;
        }

        // Draw stars background
        function drawStars(ctx, frameCount) {
            ctx.fillStyle = WHITE;
            for (let i = 0; i < 50; i++) {
                const x = (i * 137) % WIDTH;
                const y = (i * 219 + frameCount) % HEIGHT;
                ctx.beginPath();
                ctx.arc(x, y, 1, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        // Play death cutscene
        async function playDeathCutscene(player, enemies, score, lives, frameCount) {
            // Create explosion particles
            const particles = [];
            for (let i = 0; i < 30; i++) {
                particles.push(new ExplosionParticle(
                    player.x + player.width / 2,
                    player.y + player.height / 2
                ));
            }

            const cutsceneFrames = 90; // 1.5 seconds

            for (let frame = 0; frame < cutsceneFrames; frame++) {
                // Continue enemy movement during cutscene
                for (const enemy of enemies) {
                    enemy.updateDive();
                }

                // Drawing
                ctx.fillStyle = BLACK;
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                // Draw stars background
                drawStars(ctx, frameCount + frame);

                // Update and draw explosion particles
                for (const particle of particles) {
                    particle.update();
                    particle.draw(ctx);
                }

                // Draw enemies (but not their bullets)
                for (const enemy of enemies) {
                    enemy.draw(ctx);
                }

                // Draw UI
                ctx.fillStyle = WHITE;
                ctx.font = '36px Arial';
                ctx.fillText(`Score: ${score}`, 10, 40);
                ctx.fillText(`Lives: ${lives}`, WIDTH - 150, 40);

                // Flash "SHIP DESTROYED" message
                if (frame < 60 && Math.floor(frame % 20) < 15) {
                    ctx.fillStyle = RED;
                    ctx.font = '72px Arial';
                    const text = 'SHIP DESTROYED!';
                    const textWidth = ctx.measureText(text).width;
                    ctx.fillText(text, WIDTH / 2 - textWidth / 2, HEIGHT / 2);
                }

                await new Promise(resolve => setTimeout(resolve, 1000 / FPS));
            }
        }

        // Game state
        let player = new Player();
        let enemies = createEnemyFormation();
        let score = 0;
        let lives = 3;
        let gameOver = false;
        let gameSpeed = 1.0;
        let direction = 1;
        let moveDown = false;
        let frameCount = 0;
        let shootCooldown = 0;

        // Reset game
        function resetGame() {
            player = new Player();
            enemies = createEnemyFormation();
            score = 0;
            lives = 3;
            gameOver = false;
            gameSpeed = 1.0;
            direction = 1;
            frameCount = 0;
            shootCooldown = 0;
        }

        // Main game loop
        async function gameLoop() {
            frameCount++;

            // Handle restart
            if (keys['r'] && gameOver) {
                resetGame();
            }

            if (!gameOver) {
                player.move();
                player.updateInvulnerability();

                // Shooting
                if (keys[' '] && shootCooldown === 0) {
                    player.shoot();
                    shootCooldown = 15;
                }

                if (shootCooldown > 0) {
                    shootCooldown -= 1;
                }

                // Move enemies in formation
                if (frameCount % 30 === 0) {
                    let edgeHit = false;
                    for (const enemy of enemies) {
                        if (!enemy.diving) {
                            if (enemy.x <= 10 || enemy.x >= WIDTH - 40) {
                                edgeHit = true;
                                break;
                            }
                        }
                    }

                    if (edgeHit) {
                        direction *= -1;
                        moveDown = true;
                    } else {
                        moveDown = false;
                    }

                    for (const enemy of enemies) {
                        enemy.moveFormation(direction, moveDown);
                    }
                }

                // Random enemy diving
                if (frameCount % 120 === 0 && enemies.length > 0) {
                    const diver = randomChoice(enemies);
                    if (!diver.diving) {
                        diver.startDive(player.x);
                    }
                }

                // Update diving enemies
                for (const enemy of enemies) {
                    enemy.updateDive();

                    // Check if enemy collides with player
                    if (enemy.checkPlayerCollision(player) && !player.invulnerable) {
                        lives -= 1;

                        if (lives > 0) {
                            // Play death cutscene
                            await playDeathCutscene(player, enemies, score, lives, frameCount);

                            // Reset player position and make invulnerable
                            player.x = WIDTH / 2;
                            player.y = HEIGHT - 60;
                            player.invulnerable = true;
                            player.invulnTimer = 0;

                            // Clear all enemy bullets
                            for (const e of enemies) {
                                e.bullets = [];
                            }
                        } else {
                            gameOver = true;
                            break;
                        }
                    }

                    // Enemy shooting
                    if (Math.random() < 0.002) {
                        enemy.shoot();
                    }
                }

                // Update player bullets
                score += player.updateBullets(enemies);

                // Update enemy bullets
                for (const enemy of enemies) {
                    for (let i = enemy.bullets.length - 1; i >= 0; i--) {
                        const bullet = enemy.bullets[i];
                        bullet.move();
                        
                        if (bullet.y > HEIGHT) {
                            enemy.bullets.splice(i, 1);
                        } else if (bullet.checkCollision(player) && !player.invulnerable) {
                            enemy.bullets.splice(i, 1);
                            lives -= 1;

                            if (lives > 0) {
                                // Play death cutscene
                                await playDeathCutscene(player, enemies, score, lives, frameCount);

                                // Reset player position and make invulnerable
                                player.x = WIDTH / 2;
                                player.y = HEIGHT - 60;
                                player.invulnerable = true;
                                player.invulnTimer = 0;

                                // Clear all enemy bullets
                                for (const e of enemies) {
                                    e.bullets = [];
                                }
                            } else {
                                gameOver = true;
                            }
                        }
                    }
                }

                // Check if all enemies destroyed
                if (enemies.length === 0) {
                    gameSpeed *= 1.2; // Increase speed by 20%
                    enemies = createEnemyFormation(gameSpeed);
                }
            }

            // Drawing
            ctx.fillStyle = BLACK;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Draw stars background
            drawStars(ctx, frameCount);

            player.draw(ctx);

            for (const bullet of player.bullets) {
                bullet.draw(ctx);
            }

            for (const enemy of enemies) {
                enemy.draw(ctx);
                for (const bullet of enemy.bullets) {
                    bullet.draw(ctx);
                }
            }

            // Draw UI
            ctx.fillStyle = WHITE;
            ctx.font = '36px Arial';
            ctx.fillText(`Score: ${score}`, 10, 40);
            ctx.fillText(`Lives: ${lives}`, WIDTH - 150, 40);

            if (gameOver) {
                ctx.fillStyle = RED;
                ctx.font = '36px Arial';
                let text = 'GAME OVER';
                let textWidth = ctx.measureText(text).width;
                ctx.fillText(text, WIDTH / 2 - textWidth / 2, HEIGHT / 2 - 20);

                ctx.fillStyle = WHITE;
                text = 'Press R to Restart';
                textWidth = ctx.measureText(text).width;
                ctx.fillText(text, WIDTH / 2 - textWidth / 2, HEIGHT / 2 + 20);
            }

            requestAnimationFrame(gameLoop);
        }

        // Start the game
        gameLoop();
    </script>
</body>
</html>
